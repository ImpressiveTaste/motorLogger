"""
Current Loop Tuning using PyX2CScope
"""
import re
import time
import argparse

from pyx2cscope.x2cscope import X2CScope
import matplotlib.pyplot as plt
from pyx2cscope.x2cscope import TriggerConfig
from pathlib import Path
from bs4 import BeautifulSoup
import pandas as pd
from io import StringIO
import os, shutil, yaml

TEST_GUARD_VALID        = 53670
TEST_OPMODE_DISABLE     = 0
TEST_OPMODE_CURRENT     = 2
TEST_OPMODE_VOLTAGE     = 1
TEST_OVERRIDE_ENABLE    = 2
TEST_SQWAVE_ENABLE      = 1
TEST_SQWAVE_DISABLE     = 0
TEST_THETA_ELECTRICAL   = 0

TEST_PERTURB_PERIOD = 0.05            # perturbation period in seconds 
TEST_SCOPE_SAMPLE_PRESCALER = 1       # retain at 1 for max time domain resolution
TEST_PERTURB_CYCLE_DISPLAY = 1.5      # how many perturb cycles to show on the plot
TEST_SCOPE_PLOT_TRIGGER_DELAY = 0.1   # trigger delay as a fraction of the scope display

elf_path_ext  = '/dist/default/production/'
html_path_ext = '/mcc_generated_files/motorBench/aux-files/report.html'
foc_parms_ext = '/mcc_generated_files/motorBench/parameters/foc_params.h'

class htmlread:
     """
     Struture for storing data from the HTML File
     """
     currentscaling: float = None
     voltagescaling: float = None
     peakcurrent: float    = None
     rpmscaling: float     = None 

def plot_data(data_storage):
    """
    Plots all the collected data for visual analysis.
    """
    plt.clf()
    for channel, data in data_storage.items():
        plt.plot(time_axis, data, label=f"{channel}")
    plt.xlabel("Time (ms)")
    plt.ylabel("Current [A]")
    plt.title("Plot of current controller step response test")
    leg = plt.legend(loc='best').set_draggable(True)
    plt.grid(True)
    plt.show(block=False)
    plt.savefig('CurrentLoopTuning.png')
    
    time.sleep(1)

def read_html_file(html_file):
    """
    Reads the HTML file generated by the MPLAB Code Configurator.
    """
    with open(html_file, encoding="utf-8") as file:
        html_file_r = file.read()

    # Parse the HTML file using BeautifulSoup
    soup = BeautifulSoup(html_file_r, 'lxml')

    # Find all tables in the HTML
    tables = soup.find_all("table")

    # Variable to store the result
    result = None

    # Iterate through each table and convert it to a pandas DataFrame
    for i, table in enumerate(tables):
        # Convert the table HTML to a string
        table_html = str(table)

        # Wrap the HTML string in a StringIO object
        table_string = StringIO(table_html)

        # Convert the table to a DataFrame
        df = pd.read_html(table_string)[0]  # Convert the table HTML to a DataFrame

        # Search for a specific value in the DataFrame
        if "MCAF_U_CURRENT" in df.values:
            # Find the row containing "MCAF_U_CURRENT"
            CurrentColumn = df[df.isin(["MCAF_U_CURRENT"]).any(axis=1)]

            # Check if the DataFrame has more than 5 columns
            if CurrentColumn.shape[1] > 5:
                # Extract the value from the 6th column (index 5)
                currentScalingString = CurrentColumn.iloc[:, 5]
                currentScaling = currentScalingString.values
                peakCurrentString = CurrentColumn.iloc[:, 2]
                peakCurrent = peakCurrentString.values
                
                # Store the result and break the loop
                currentGain = currentScaling.item()
                peakCurrentA = peakCurrent.item()

        # Search for a specific value in the DataFrame
        if "MCAF_U_VOLTAGE" in df.values:
            # Find the row containing "MCAF_U_VOLTAGE"
            VoltageColumn = df[df.isin(["MCAF_U_VOLTAGE"]).any(axis=1)]

            # Check if the DataFrame has more than 5 columns
            if VoltageColumn.shape[1] > 5:
                # Extract the value from the 6th column (index 5)
                voltageScalingString = VoltageColumn.iloc[:, 5]
                voltageScaling = voltageScalingString.values

                # Store the result and break the loop
                voltageGain = voltageScaling.item()

    # Print the results if found
    if currentGain is not None:
        print("Current Gain:", currentGain)
        print("Full Scale Current:", peakCurrentA)
        htmlread.currentscaling = currentGain
        htmlread.peakcurrent = peakCurrentA
    else:
        print("MCAF_U_CURRENT not found in the HTML file.")

    if voltageGain is not None:
        print("Voltage Gain:", voltageGain)
        htmlread.voltagescaling = voltageGain
    else:
        print("MCAF_U_VOLTAGE not found in the HTML file.")
    return htmlread()

def edit_foc_params(focparam_file, kip_value, kip_q_value, kii_value, kii_q_value):
    """
    Function for replacing the tuned values in mB code
    """
    with open(focparam_file, 'r') as file:
        content = file.read()

    # Define the pattern to match the section from //// Current loop to //// Velocity loop
    pattern = re.compile(r'(//// Current loop.*?//// Velocity loop)', re.DOTALL)

    # Define the replacement content using the provided variables
    replacement = f'''//// Current loop
// Tuned gain values from the pyx2cscope tuning assistant
/* Current loop proportional gain */
#define KIP                                  {kip_value}    
#define KIP_Q                                  {kip_q_value}
/* Current loop integral gain */
#define KII                                   {kii_value}   
#define KII_Q                                 {kii_q_value}
//// Velocity loop'''

    # Replace the matched section with the replacement content
    new_content = pattern.sub(replacement, content)

    # Write the modified content back to the file
    with open(focparam_file, 'w') as file:
        file.write(new_content)

def config_file_exists(cwd):
    """
    Checks if the configuration file exists in the expected location.
    If it does not exist, it copies the template configuration file to the expected location.
    """
    config_file_path = os.path.join(cwd, '..', 'config.yaml')
    template_file_path = os.path.join(cwd, '..', 'config-template.yaml')
    
    if not os.path.isfile(config_file_path):
        print("../config.yaml not found. Copying from template...")
        shutil.copy(template_file_path, config_file_path)
        return False
    else:
        print("../config.yaml found. Using existing configuration.")
        return True

def read_scope_buffer_size(folder_path):
    """
    Reads out the X2Cscope buffer memory size from diagnostics.c file in MCAF project
    """
    pattern = r"#define\s+X2C_BUFFER_SIZE\s+(\d+)"
    
    for root, _, files in os.walk(folder_path):
        for file in files:
            file_path = os.path.join(root, file)
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    match = re.search(pattern, content)
                    if match:
                        return int(match.group(1))
            except (OSError, UnicodeDecodeError):
                # Skip files that cannot be opened or read
                pass
    return None

def parse_data_model(file_path):
    """
    Parses data model dump file and returns the data model as a dictionary.
    """
    if not os.path.isfile(file_path):
        print("File not found: {}".format(file_path))
        return None

    with open(file_path, 'r') as file:
        try:
            data_model = yaml.load(file, Loader=yaml.FullLoader)  # Use FullLoader for safety
            return data_model
        except yaml.YAMLError as e:
            return None

def get_sampling_time(data_model):
    """
    Gets the sampling time for current loop from the data model.
    """
    try:
        sampling_time = data_model.get('drive', {}).get('sampling_time', {}).get('current')
        return float(sampling_time)
    except KeyError:
        print("Key 'drive.sampling_time.current' not found in data model.")
        return None

if __name__ == '__main__':

    # get test configuration
    cwd = os.path.dirname(os.path.abspath(__file__))
    config_file_path = os.path.join(cwd, '..', 'config.yaml')
    if not config_file_exists(cwd):
        input("\n  Update the ../config.yaml and hit enter when ready to continue")
    with open(config_file_path, 'r') as file:
        config = yaml.load(file, Loader=yaml.FullLoader)
    project_path = Path(config.get('config', {}).get('project_folder'))
    com_port = config.get('config', {}).get('com_port')
    
    match = re.search(r'([^\\]+)\.X$', str(project_path))
    if match:
        project_name = match.group(1)
    else:
        print("WARNING: Unable to parse the project name. Verify the path to MPLAB X project and try again.")
        raise SystemExit

    elf_file = str(project_path)+elf_path_ext+project_name+'.X.production.elf'
    html_file = str(project_path)+html_path_ext
    focparam_file = str(project_path)+foc_parms_ext

    # Get the Scaling Gains from the HTML File
    valuesHTML = read_html_file(html_file)
    scalingGainCurrent = valuesHTML.currentscaling
    scalingGainVoltage = valuesHTML.voltagescaling
    fullsacleCurrent = valuesHTML.peakcurrent

    dataModel = parse_data_model(os.path.join(project_path,'data-model-dump.yaml'))

    # set up the COM Port and ELF file for for X2C scope
    x2c_scope = X2CScope(port=com_port, elf_file=elf_file)

    # # Get the enum variables by importing from its address
    # x2c_scope.import_variables(yaml_file)
    time.sleep(1)

    # Get the variables from the dsPIC project
    class x2cscope:
        def __init__(self):
            self.testModeGuardKey   = x2c_scope.get_variable("systemData.testing.guard.key")
            self.testOperatingMode  = x2c_scope.get_variable("motor.testing.operatingMode")
            self.testOverride       = x2c_scope.get_variable("motor.testing.overrides")
            self.thetaElectrical    = x2c_scope.get_variable("motor.thetaElectrical")
            self.idqCmdRawQ         = x2c_scope.get_variable("motor.idqCmdRaw.q")
            self.sqwaveHalfperiod   = x2c_scope.get_variable("motor.testing.sqwave.halfperiod")
            self.sqwaveIq           = x2c_scope.get_variable("motor.testing.sqwave.idq.q")
            self.idqCmdQ            = x2c_scope.get_variable("motor.idqCmd.q")
            self.idqQ               = x2c_scope.get_variable("motor.idq.q")
            self.iQKp               = x2c_scope.get_variable("motor.iqCtrl.kp")
            self.iQnKp              = x2c_scope.get_variable("motor.iqCtrl.nkp")
            self.iQKi               = x2c_scope.get_variable("motor.idCtrl.ki")
            self.iQnKi              = x2c_scope.get_variable("motor.idCtrl.nki")
            self.iDKp               = x2c_scope.get_variable("motor.idCtrl.kp")
            self.iDnKp              = x2c_scope.get_variable("motor.idCtrl.nkp")
            self.iDKi               = x2c_scope.get_variable("motor.idCtrl.ki")
            self.iDnKi              = x2c_scope.get_variable("motor.idCtrl.nki")
            self.testSqwaveValue    = x2c_scope.get_variable("motor.testing.sqwave.value")
            
    xc = x2cscope()

    AverageCurrentCommand = float(input("\n  Enter Average Current Command in A for the Test:"))
    PerturbationCurrent   = float(input("\n  Enter Pertubation Current Amplitude in A for the Test:"))
    if ((AverageCurrentCommand+PerturbationCurrent) > fullsacleCurrent):
        print("\n  ERROR: The sum of the Average Current Command and Perturbation Current Amplitude is greater than the full scale current.  Please re-enter the values.")
        AverageCurrentCommand = float(input("\n  Enter Average Current Command in A for the Test:"))
        PerturbationCurrent   = float(input("\n  Enter Pertubation Current Amplitude in A for the Test:"))        

    averageCurrentCommand        = int(AverageCurrentCommand/scalingGainCurrent)
    perturbationCurrentAmplitude = int(PerturbationCurrent/scalingGainCurrent)

    # Setup the override options
    xc.testModeGuardKey.set_value(TEST_GUARD_VALID)
    xc.testOperatingMode.set_value(TEST_OPMODE_DISABLE)
    xc.testOverride.set_value(TEST_OVERRIDE_ENABLE)
    xc.thetaElectrical.set_value(TEST_THETA_ELECTRICAL)
    xc.idqCmdRawQ.set_value(averageCurrentCommand)
    xc.sqwaveIq.set_value(perturbationCurrentAmplitude)
    time.sleep(1)

    # Adding the variables to the scope to monitor the channels
    x2c_scope.add_scope_channel(xc.idqQ)
    x2c_scope.add_scope_channel(xc.idqCmdQ)
    scope_channel_count = len(x2c_scope.get_scope_channel_list())

    try:
        sampleTime = get_sampling_time(dataModel)
    except AttributeError:
        print("Error: could not parse out sampling time for current loop from data model, assuming it to be 50us")
        sampleTime = 50.0e-6 
    sampleTimeScope = sampleTime * (TEST_SCOPE_SAMPLE_PRESCALER+1)
    scope_buffer_size = read_scope_buffer_size(project_path)
    
    # if necessary, adjust scope sample time prescaler to achieve desired scope time window
    scopeTimeWindowDesired = TEST_PERTURB_PERIOD*TEST_PERTURB_CYCLE_DISPLAY
    scopeTimeWindowRealized = (scope_buffer_size/(2*scope_channel_count))*sampleTimeScope
    print("Desired scope time window = %.3f s"%scopeTimeWindowDesired)
    print("Realized scope time window = %.3f s"%scopeTimeWindowRealized)
    if scopeTimeWindowDesired > scopeTimeWindowRealized:
        while scopeTimeWindowDesired > scopeTimeWindowRealized:
            TEST_SCOPE_SAMPLE_PRESCALER = TEST_SCOPE_SAMPLE_PRESCALER + 1
            sampleTimeScope = sampleTime * (TEST_SCOPE_SAMPLE_PRESCALER+1)
            scopeTimeWindowRealized = (scope_buffer_size/(2*scope_channel_count))*sampleTimeScope
            print(" >> Realized scope time window = %.3f s"%scopeTimeWindowRealized)
    
    perturbPeriodCounts = int(TEST_PERTURB_PERIOD/sampleTime)
    xc.sqwaveHalfperiod.set_value(perturbPeriodCounts/2)
    
    # Setting up Trigger, any available variable can be selected.
    plotTriggerDelayCounts = int(TEST_SCOPE_PLOT_TRIGGER_DELAY*(scope_buffer_size/(2*scope_channel_count)))
    plotTriggerLevel = averageCurrentCommand+perturbationCurrentAmplitude
    trigger_config = TriggerConfig(xc.idqCmdQ, trigger_level=plotTriggerLevel, 
                                   trigger_mode=1, trigger_delay=plotTriggerDelayCounts, trigger_edge=1)
    x2c_scope.set_scope_trigger(trigger_config)
    x2c_scope.set_sample_time(TEST_SCOPE_SAMPLE_PRESCALER)

    # start the test
    xc.testOperatingMode.set_value(TEST_OPMODE_CURRENT)
    xc.testSqwaveValue.set_value(TEST_SQWAVE_ENABLE)
    time.sleep(1)

    # Storing the data and plotting it
    x2c_scope.request_scope_data()
    time.sleep(0.1)
    data_storage = {}
    try:
        while not x2c_scope.is_scope_data_ready():
            time.sleep(0.5)
    except KeyboardInterrupt:
        pass

    # Turn off the perturbation signal
    xc.testSqwaveValue.set_value(TEST_SQWAVE_DISABLE)
    xc.testOperatingMode.set_value(TEST_OPMODE_DISABLE)

    for channel, data in x2c_scope.get_scope_channel_data(valid_data=True).items():
            data = [item * valuesHTML.currentscaling for item in data]
            data_storage[channel] = data

    for channel, data in data_storage.items():
            time_axis = [i * sampleTimeScope for i in range(len(data))]
    time.sleep(1)

    # Plotting the data
    plot_data(data_storage)

    tuningParmsChanged = False

    # Check for Tuning Requirement
    while True:
        Tuning_Req = input("\n  Do you want to tune the PI controller? (y/n): ").lower()
        if Tuning_Req == 'y':
            tuningParmsChanged = True
            # Display the Current Controller Gains
            print("  iQKp =", xc.iQKp.get_value(), "iQnKp = Q",15-xc.iQnKp.get_value())
            print("  iQKi =", xc.iQKi.get_value(), "iQnKp = Q",15-xc.iQnKi.get_value())

            # Take the new Kp Ki values from the user
            KpNew = int(input("\n  Enter new Kp integer value: "))
            KiNew = int(input("\n  Enter new Ki integer value: "))
            nKpNew = int(input("\n  Enter new Kp Q format value: "))
            nKiNew = int(input("\n  Enter new Ki Q format value: "))

            #Check if the new values are within the range
            while(1):
                if KpNew < 1 or KpNew > 32767:
                    print("\n  Kp value out of range. Please enter a value between 1 and 32767")
                    KpNew = int(input("\n  Enter new Kp integer value: "))
                    continue
                if KiNew < 1 or KiNew > 32767:
                        print("\n  Ki value out of range. Please enter a value between 1 and 32767")
                        KiNew = int(input("\n  Enter new Ki integer value: "))
                        continue
                if nKpNew < 8 or nKpNew > 15:
                        print("\n  Kp Q format value out of range. Please enter a value between 8 and 15")
                        nKpNew = int(input("\n  Enter new Kp Q format value: "))
                        continue
                if nKiNew < 12 or nKiNew > 15:
                        print("\n  Ki Q format value out of range. Please enter a value between 12 and 15")
                        nKiNew = int(input("\n  Enter new Ki Q format value: "))
                        continue
                else:
                     break

            # Set the new Kp Ki values to the controller
            xc.iQKp.set_value(KpNew)
            xc.iQKi.set_value(KiNew)
            xc.iQnKp.set_value(15-nKpNew)
            xc.iQnKi.set_value(15-nKiNew)
            time.sleep(1)

            #Print the new Kp Ki values
            print("\n New Kp Ki values are ")
            print("  iQKp =", xc.iQKp.get_value(), "iQnKp = Q",15-xc.iQnKp.get_value())
            print("  iQKi =", xc.iQKi.get_value(), "iQnKp = Q",15-xc.iQnKi.get_value())
            
            xc.testOperatingMode.set_value(TEST_OPMODE_CURRENT)
            xc.testSqwaveValue.set_value(TEST_SQWAVE_ENABLE)
            time.sleep(1)

            # Storing the data and plotting
            x2c_scope.request_scope_data()
            time.sleep(0.1)
            data_storage = {} 
            try:
                while not x2c_scope.is_scope_data_ready():
                    time.sleep(0.5)
            except KeyboardInterrupt:
                pass

            # Turn off the perturbation signal
            xc.testSqwaveValue.set_value(TEST_SQWAVE_DISABLE)
            xc.testOperatingMode.set_value(TEST_OPMODE_DISABLE)

            for channel, data in x2c_scope.get_scope_channel_data(valid_data=True).items():
                data = [item * valuesHTML.currentscaling for item in data]
                data_storage[channel] = data
            
            for channel, data in data_storage.items():
                time_axis = [i * sampleTimeScope for i in range(len(data))]
            time.sleep(1)

            # Plotting the data
            plot_data(data_storage)

        elif Tuning_Req == 'n':
            print("\n  No further tuning requested")
            time.sleep(1)
            break
        
        else:
            print("  Error: Invalid input. Please enter 'y' or 'n'.")
            pass


    if tuningParmsChanged:
        kip_value = xc.iQKp.get_value()
        kii_value = xc.iQKi.get_value()
        kip_q_value = 15-xc.iQnKp.get_value()
        kii_q_value = 15-xc.iQnKi.get_value()
        time.sleep(1)
        # Call the function to edit the foc_params.h file
        edit_foc_params(focparam_file, kip_value, kip_q_value, kii_value, kii_q_value)  
        time.sleep(1)
        print("\n  foc_params.h file updated with new current PI contoller gains")

    with open("Tuned_Controller_Gains.txt", 'w') as f:
        f.write("Tuned Controller Gains are: \n")
        f.write("\n #define KIP          ")
        print(xc.iQKp.get_value(), file=f)
        f.write("\n #define KIP_Q        ")
        print(15-xc.iQnKp.get_value(), file=f)
        f.write("\n #define KII          ")
        print(xc.iQKi.get_value(), file=f)
        f.write("\n #define KII_Q        ")
        print(15-xc.iQnKi.get_value(), file=f)

    time.sleep(1)

    print("\n  Tuning parameters text file created")
    print("\n  Tuning Completed")
